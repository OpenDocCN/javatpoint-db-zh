# 多列索引

> 原文:[https://www.javatpoint.com/postgresql-multi-column-indexes](https://www.javatpoint.com/postgresql-multi-column-indexes)

在本节中，我们将了解 **PostgreSQL 多列索引的创建，这些索引**是在一个表的多个列上指定的。

## 什么是 PostgreSQL 多列索引？

我们可以在表的不同列上创建索引；这样的指数被称为**多栏指数**。

换句话说，我们可以说**多列索引**是那些索引，它们是用一个表的几列创建的。

**多栏指数**也称为**综合指数、串联指数和组合指数。**

一个表最多可以有 32 列**。在构建 [PostgreSQL](https://www.javatpoint.com/postgresql-tutorial) 时，可以通过修改 **pg_config_manual.h** 来更改限制。**

此外，多列索引只支持 **B 树、GIST、GIN 和 BRIN** 类型的索引。

### PostgreSQL 多列索引的语法

PostgreSQL 多列索引的语法如下:

```

CREATE INDEX index_name  
ON table_name (p, q,r,….);

```

#### 注意:在上面的语法中，p，q，r 被认为是一个列名。

如果要指定多列索引，应该将[**【WHERE】**子句](https://www.javatpoint.com/postgresql-where-clause)中经常使用的列放在列列表的开头，将条件中重复使用的列放在后面。

在上图中，我们有以下场景，其中 **PostgreSQL 优化器**将考虑使用索引:

```

WHERE p = value1 and q = value2 and r = value3;

```

或者

```

WHERE p = value1 and q = value2;

```

或者

```

WHERE p = value1;

```

但是，在以下情况下，我们将不使用索引:

```

WHERE r = value3;

```

或者

```

WHERE q = value2 and r = value3;

```

### PostgreSQL 多列索引示例

为了理解 **PostgreSQL 多列索引**的工作原理，我们将看到以下示例。

因此，我们在 **CREATE** 命令的帮助下创建一个新表作为 ***人物*** ，并使用 [**INSERT** 命令](https://www.javatpoint.com/postgresql-insert)插入一些值。

要将 ***人员*** 表创建到**组织数据库**中，我们使用 **CREATE** 命令。

***Person*** 表包含各种列，如 **Person_id、First_name、Last_name** 列，其中我们使用 **Person_id** 作为**GENERATED AS IDENTITY 约束**。

```

CREATE TABLE Person(
    Person_id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR(30) NOT NULL,
    last_name VARCHAR(30) NOT NULL
);

```

**输出**

执行上述命令时，我们将获得以下消息，显示 ***人员*** 表已成功创建到**组织**数据库中。

![PoatgreSQL Multi-column Indexes](../Images/f0bbeb7ecada3ffc33c83ed6a125b4f0.png)

成功创建 ***人物*** 表后，我们将在 **INSERT** 命令的帮助下输入一些值。

```

INSERT INTO Person (First_name, Last_name)
VALUES ('Mike', 'Ross'),
('John','Smith),
('Owen','Norman'),
('Bruce','Willis'),
('Douglas','Smith'),
('Olivia', 'Smith');

```

**输出**

在执行上述命令时，我们将获得以下消息窗口，显示指定值已成功插入 ***人员*** 表。

![PoatgreSQL Multi-column Indexes](../Images/99db5fef561fdc4a280d4e8a91de2fbd.png)

在 ***Person*** 表中创建并插入值后，我们将识别那些**姓**为**史密斯**的人，如下命令所示:

```

SELECT *
FROM Person
WHERE last_name = 'Smith';

```

**输出**

执行上述命令后，我们将得到以下输出，其中显示了**姓**属于**史密斯的所有**人**。**

![PoatgreSQL Multi-column Indexes](../Images/ca41f81de5e9e1137334201ee03bd68f.png)

在下面的命令中，我们将使用 **EXPLAIN** 命令在 ***Person*** 表上执行**顺序扫描**，这有助于我们识别等价行，因为没有为 **last_name** 列定义索引。

```

EXPLAIN
SELECT *
FROM Person
WHERE last_name = 'Smith';

```

**输出**

成功执行上述命令后，我们会得到如下结果，显示 PostgreSQL 在 ***Person*** 表上完成了顺序扫描。

![PoatgreSQL Multi-column Indexes](../Images/e7f1f74ff16d57a8a7e1e2f6167268eb.png)

目前，多列索引只支持 **B 树、GiST、GIN 和 BRIN** 索引类型。

### 带 B 树索引的 PostgreSQL 多列索引

在下面的命令中，我们在**名字和姓氏**列上定义 **B 树索引**。

让我们假设我们通过姓氏**来搜索这个人，这比通过他们的名字来搜索更频繁。**

 **因此，在下面的命令中，我们使用下面的列顺序指定索引:

```

CREATE INDEX idex_person_names 
ON Person (last_name, first_name);

```

**输出**

执行上述命令后，我们将获得以下输出，显示已经为 ***人物*** 表成功创建了 **Idex_person_names** 索引。

![PoatgreSQL Multi-column Indexes](../Images/c57d931fcfec7eb1eef8944ff198e673.png)

如果我们搜索一个姓氏为**史密斯**的人，PostgreSQL 优化器将使用该索引，如下命令所示:

```

EXPLAIN 
SELECT *
FROM Person
WHERE last_name = 'Smith';

```

**输出**

执行上述命令后，我们将获得以下输出:

![PoatgreSQL Multi-column Indexes](../Images/e9474e55de6fbd49953c5c6be2ca8cea.png)

在上面的截图中，我们会看到**查询计划**只使用**顺序扫描，**不使用索引，因为我们的表中没有足够的数据供计划员使用索引。

因此，要查看特定表的索引，我们必须使用以下命令:

```

 SET enable_seqscan = off;

```

**输出**

执行上述命令后，我们将获得以下消息窗口:特定命令已成功设置。

![PoatgreSQL Multi-column Indexes](../Images/14c523fa16cb528eb6202256bf9ffc8c.png)

执行 **SET** 命令后，我们将再次执行 **EXPLAIN** 命令，我们将得到如下输出，显示查询计划中的索引:

![PoatgreSQL Multi-column Indexes](../Images/5ca7ae5ae8d924531c2b07939c0f9a7a.png)

在下一个命令中，我们将识别那些姓氏为**史密斯**而**名字为**约翰的人:

```

SELECT *
FROM Person
WHERE last_name = 'Smith'
AND first_name = 'John';

```

**输出**

执行上述命令时，我们会收到以下信息，显示那些**名为**约翰****姓为**史密斯**的人:****

![PoatgreSQL Multi-column Indexes](../Images/f6477563f56c177f7053824aa4d0d398.png)

之后，PostgreSQL 优化器使用上述命令的索引作为 **WHERE** 子句中属于索引的两列(**名和姓**):

```

EXPLAIN
SELECT *
FROM Person
WHERE last_name = 'Smith'
AND first_name = 'John';

```

**输出**

执行上述命令后，我们将得到下面的结果:PostgreSQL 优化器使用了*表的**名和姓氏**列的索引。*

*![PoatgreSQL Multi-column Indexes](../Images/ff4c59b8256a1386bef222b03180cdea.png)

但是，如果我们搜索名字为 **John、**的人，那么 PostgreSQL 将对表执行**顺序扫描**，而不是使用索引，如下命令所示:

```

EXPLAIN
SELECT *
FROM Person
WHERE first_name = 'John';

```

**输出**

执行上述命令后，我们将获得以下输出，显示 PostgreSQL 优化器执行特定表的顺序扫描。

![PoatgreSQL Multi-column Indexes](../Images/a2125e2a9fbe89424429881737c8c90e.png)

#### 注意:即使 first_name 列与索引相关，PostgreSQL 也不能强制它。

### 带有 GIN 索引的 PostgreSQL 多列索引

*   PostgreSQL 多列 **GIN 索引**可以与查询设置一起使用，包括索引列的任何子集。
*   与 **B 树或 GiS** T 不同，索引搜索效率相似，并且与查询条件使用的索引列无关。

### 带有 GiST 索引的 PostgreSQL 多列索引

*   PostgreSQL 多列 GiST 索引还与查询条件相结合，查询条件包含索引列的任何子集。
*   附加列上的条件检查索引检索到的条目。
*   要定义需要扫描多少索引，**第一列**上的条件应该是主要的。
*   如果它的第一列只包含有限的不同值，即使在其他列中有几个不同的值， **GiST 索引**也会相对不成功。

### 带有 BRIN 索引的 PostgreSQL 多列索引

*   PostgreSQL 多列 **BRIN 索引**可以与查询条件一起使用，查询条件包含索引列的任何子类别。
*   类似的 **GIN** 和不同的 **B 树或 GiST** ，索引搜索效率是相似的，并且与查询条件使用的索引列无关。
*   最重要的目的之一是在单个表上获取多个 **BRIN 索引**而不是一个多列 BRIN 索引，这是为了具有不同的 **page_per_range** 存储约束。

#### 注意:当我们指定多列索引时，我们应该始终使用业务环境来标识哪些列经常用于查找，并在指定索引时在列列表的开头使用它们。

### 概观

*   在本节中，我们已经了解了 PostgreSQL 多列索引和列顺序的重要性。
*   可以谨慎使用 **PostgreSQL 多列索引**。在大多数情况下，单个列上的索引就足够了，并且节省了空间和时间。
*   并且我们还了解到 PostgreSQL 多列索引只能支持 **B-tree、GiST、GIN 和 BRIN** 类型的索引。

* * ****